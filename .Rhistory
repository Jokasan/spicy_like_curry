) %>%
set_engine("xgboost") %>%
set_mode("classification")
steph_workflow <- workflow() %>%
add_recipe(steph_recipe) %>%
add_model(xgb_spec)
xgb_grid <- grid_latin_hypercube(
tree_depth(),
min_n(),
loss_reduction(),
sample_size = sample_prop(),
finalize(mtry(), music_train),
learn_rate(),
size = 30
)
xgb_grid <- grid_latin_hypercube(
tree_depth(),
min_n(),
loss_reduction(),
sample_size = sample_prop(),
finalize(mtry(), steph_train),),
xgb_grid <- grid_latin_hypercube(
tree_depth(),
min_n(),
loss_reduction(),
sample_size = sample_prop(),
finalize(mtry(), steph_train),
learn_rate(),
size = 30
)
xgb_grid
doParallel::registerDoParallel() # Activate parallel computing
set.seed(1234)
xgb_results <-  tune_grid(
music_wf,
resamples = steph_folds,
grid = xgb_grid,
control = control_grid(save_pred = TRUE)
)
doParallel::registerDoParallel() # Activate parallel computing
set.seed(1234)
xgb_results <-  tune_grid(
steph_workflow,,
resamples = steph_folds,
grid = xgb_grid,
control = control_grid(save_pred = TRUE)
)
doParallel::registerDoParallel() # Activate parallel computing
set.seed(1234)
xgb_results <-  tune_grid(
steph_workflow,
resamples = steph_folds,
grid = xgb_grid,
control = control_grid(save_pred = TRUE)
)
show_notes(.Last.tune.result)
nba_pbp %>%
filter(season <= 2023 &
athlete_id_1 == 3975 &
shooting_play == TRUE &
!grepl("Free Throw",type_text)) %>%
select(game_id,coordinate_x_raw,coordinate_y_raw,scoring_play,
clock_minutes, athlete_id_2,clock_minutes,clock_seconds,qtr) %>%
left_join(player_ids,by=c("athlete_id_2"="athlete_id")) %>%
left_join(game_ids, by=join_by(game_id)) %>%
select(-athlete_id_2) %>%
rename(oponent_athlete=athlete_display_name) %>%
mutate(oponent_athlete = if_else(is.na(oponent_athlete),"no direct oponent",oponent_athlete),
scoring_play = as_factor(scoring_pla))-> base_steph_pbp
nba_pbp %>%
filter(season <= 2023 &
athlete_id_1 == 3975 &
shooting_play == TRUE &
!grepl("Free Throw",type_text)) %>%
select(game_id,coordinate_x_raw,coordinate_y_raw,scoring_play,
clock_minutes, athlete_id_2,clock_minutes,clock_seconds,qtr) %>%
left_join(player_ids,by=c("athlete_id_2"="athlete_id")) %>%
left_join(game_ids, by=join_by(game_id)) %>%
select(-athlete_id_2) %>%
rename(oponent_athlete=athlete_display_name) %>%
mutate(oponent_athlete = if_else(is.na(oponent_athlete),"no direct oponent",oponent_athlete),
scoring_play = as_factor(scoring_play))-> base_steph_pbp
base_steph_pbp
base_steph_pbp
as_factor()
?as_factor()
nba_pbp %>%
filter(season <= 2023 &
athlete_id_1 == 3975 &
shooting_play == TRUE &
!grepl("Free Throw",type_text)) %>%
select(game_id,coordinate_x_raw,coordinate_y_raw,scoring_play,
clock_minutes, athlete_id_2,clock_minutes,clock_seconds,qtr) %>%
left_join(player_ids,by=c("athlete_id_2"="athlete_id")) %>%
left_join(game_ids, by=join_by(game_id)) %>%
select(-athlete_id_2) %>%
rename(oponent_athlete=athlete_display_name) %>%
mutate(oponent_athlete = if_else(is.na(oponent_athlete),"no direct oponent",oponent_athlete),
scoring_play = as_factor(scoring_play))-> base_steph_pbp
library(tidymodels)
set.seed(123)
steph_split <- initial_split(base_steph_pbp, prop = 0.8, strata = scoring_play)
steph_train <- training(steph_split)
steph_test <- testing(steph_split)
steph_folds <- vfold_cv(steph_train, v = 10, strata = scoring_play)
steph_recipe <- recipe(scoring_play ~ ., data = steph_train) %>%
update_role(game_id, new_role = "ID") %>%
step_dummy(all_nominal(), -all_outcomes())
xgb_spec <- boost_tree(
trees = 1000,
tree_depth = tune(),
min_n = tune(),
loss_reduction = tune(),
sample_size = tune(),
mtry = tune(),
learn_rate = tune()
) %>%
set_engine("xgboost") %>%
set_mode("classification")
steph_workflow <- workflow() %>%
add_recipe(steph_recipe) %>%
add_model(xgb_spec)
xgb_grid <- grid_latin_hypercube(
tree_depth(),
min_n(),
loss_reduction(),
sample_size = sample_prop(),
finalize(mtry(), steph_train),
learn_rate(),
size = 30
)
doParallel::registerDoParallel() # Activate parallel computing
set.seed(1234)
xgb_results <-  tune_grid(
steph_workflow,
resamples = steph_folds,
grid = xgb_grid,
control = control_grid(save_pred = TRUE)
)
xgb_results
xgb_results %>%
collect_metrics() %>%
filter(.metric == "roc_auc") %>%
select(mean, mtry:sample_size) %>%
pivot_longer(mtry:sample_size,
values_to = "value",
names_to = "parameter"
) %>%
ggplot(aes(value, mean)) +
geom_point(alpha = 0.8, show.legend = FALSE, color="midnightblue") +
facet_wrap(~parameter, scales = "free_x") +
labs(x = NULL, y = "AUC")+
scale_color_brewer(palette = "Spectral")+
theme_minimal()
best_auc_model <- select_best(xgb_results,"roc_auc")
final_xgb <- finalize_workflow(
steph_workflow,
best_auc_model
)
final_xgb
final_xgb %>%
fit(data = music_train) %>%
extract_fit_parsnip() %>%
vip(geom = "point") +
theme_minimal()
library(vip)
final_xgb %>%
fit(data = music_train) %>%
extract_fit_parsnip() %>%
vip(geom = "point") +
theme_minimal()
final_xgb %>%
fit(data = steph_train) %>%
extract_fit_parsnip() %>%
vip(geom = "point") +
theme_minimal()
final_res <- last_fit(final_xgb, steph_split)
final_res
final_res %>%
collect_predictions()
final_res %>%
collect_predictions() %>%
roc_curve(genre, `.pred_TRUE `) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_line(linewidth = 1.5, color = "midnightblue") +
geom_abline(
lty = 2, alpha = 0.5,
color = "gray50",
linewidth = 1.2
)+theme_minimal()
final_res %>%
collect_predictions() %>%
roc_curve(scoring_play, `.pred_TRUE `) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_line(linewidth = 1.5, color = "midnightblue") +
geom_abline(
lty = 2, alpha = 0.5,
color = "gray50",
linewidth = 1.2
)+theme_minimal()
final_res %>%
collect_predictions() %>%
roc_curve(scoring_play, `.pred_TRUE`) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_line(linewidth = 1.5, color = "midnightblue") +
geom_abline(
lty = 2, alpha = 0.5,
color = "gray50",
linewidth = 1.2
)+theme_minimal()
final_res %>%
collect_predictions() %>%
roc_curve(scoring_play, `.pred_FALSE`) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_line(linewidth = 1.5, color = "midnightblue") +
geom_abline(
lty = 2, alpha = 0.5,
color = "gray50",
linewidth = 1.2
)+theme_minimal()
collect_metrics(final_res)
collect_predictions(final_res) %>%
conf_mat(scoring_play, .pred_class) %>%
autoplot()+
theme_minimal()
skimr::skim(base_steph_pbp)
nba_pbp %>%
filter(season <= 2023 &
athlete_id_1 == 3975 &
shooting_play == TRUE &
!grepl("Free Throw",type_text)) %>%
select(game_id,coordinate_x_raw,coordinate_y_raw,scoring_play,
clock_minutes, athlete_id_2,clock_minutes,clock_seconds,qtr) %>%
left_join(player_ids,by=c("athlete_id_2"="athlete_id")) %>%
inner_join(game_ids, by=join_by(game_id)) %>%
select(-athlete_id_2) %>%
rename(oponent_athlete=athlete_display_name) %>%
mutate(oponent_athlete = if_else(is.na(oponent_athlete),"no direct oponent",oponent_athlete),
scoring_play = as_factor(scoring_play))-> base_steph_pbp
skimr::skim(base_steph_pbp)
# Create splits:
set.seed(123)
steph_split <- initial_split(base_steph_pbp, prop = 0.8, strata = scoring_play)
steph_train <- training(steph_split)
steph_test <- testing(steph_split)
steph_folds <- vfold_cv(steph_train, v = 10, strata = scoring_play)
# Preprocessing:
# Add new step to address NAs
steph_recipe <- recipe(scoring_play ~ ., data = steph_train) %>%
update_role(game_id, new_role = "ID") %>%
step_dummy(all_nominal(), -all_outcomes())
xgb_spec <- boost_tree(
trees = 1000,
tree_depth = tune(),
min_n = tune(),
loss_reduction = tune(),
sample_size = tune(),
mtry = tune(),
learn_rate = tune()
) %>%
set_engine("xgboost") %>%
set_mode("classification")
steph_workflow <- workflow() %>%
add_recipe(steph_recipe) %>%
add_model(xgb_spec)
xgb_grid <- grid_latin_hypercube(
tree_depth(),
min_n(),
loss_reduction(),
sample_size = sample_prop(),
finalize(mtry(), steph_train),
learn_rate(),
size = 30
)
doParallel::registerDoParallel() # Activate parallel computing
set.seed(1234)
xgb_results <-  tune_grid(
steph_workflow,
resamples = steph_folds,
grid = xgb_grid,
control = control_grid(save_pred = TRUE)
)
xgb_results %>%
collect_metrics() %>%
filter(.metric == "roc_auc") %>%
select(mean, mtry:sample_size) %>%
pivot_longer(mtry:sample_size,
values_to = "value",
names_to = "parameter"
) %>%
ggplot(aes(value, mean)) +
geom_point(alpha = 0.8, show.legend = FALSE, color="midnightblue") +
facet_wrap(~parameter, scales = "free_x") +
labs(x = NULL, y = "AUC")+
scale_color_brewer(palette = "Spectral")+
theme_minimal()
# Create splits:
set.seed(123)
steph_split <- initial_split(base_steph_pbp, prop = 0.8, strata = scoring_play)
steph_train <- training(steph_split)
steph_test <- testing(steph_split)
steph_folds <- vfold_cv(steph_train, v = 10, strata = scoring_play)
# Preprocessing:
# Add new step to address NAs
steph_recipe <- recipe(scoring_play ~ ., data = steph_train) %>%
update_role(game_id, new_role = "ID") %>%
step_dummy(all_nominal(), -all_outcomes())
xgb_spec <- boost_tree(
trees = tune(),
tree_depth = tune(),
min_n = tune(),
loss_reduction = tune(),
sample_size = tune(),
mtry = tune(),
learn_rate = tune()
) %>%
set_engine("xgboost") %>%
set_mode("classification")
steph_workflow <- workflow() %>%
add_recipe(steph_recipe) %>%
add_model(xgb_spec)
xgb_grid <- grid_latin_hypercube(
trees(),
tree_depth(),
min_n(),
loss_reduction(),
sample_size = sample_prop(),
finalize(mtry(), steph_train),
learn_rate(),
size = 30
)
)
xgb_spec <- boost_tree(
trees = tune(),
tree_depth = tune(),
min_n = tune(),
loss_reduction = tune(),
sample_size = tune(),
mtry = tune(),
learn_rate = tune()
) %>%
set_engine("xgboost") %>%
set_mode("classification")
steph_workflow <- workflow() %>%
add_recipe(steph_recipe) %>%
add_model(xgb_spec)
xgb_grid <- grid_latin_hypercube(
trees(),
tree_depth(),
min_n(),
loss_reduction(),
sample_size = sample_prop(),
finalize(mtry(), steph_train),
learn_rate(),
size = 30
)
doParallel::registerDoParallel() # Activate parallel computing
set.seed(1234)
xgb_results <-  tune_grid(
steph_workflow,
resamples = steph_folds,
grid = xgb_grid,
control = control_grid(save_pred = TRUE)
)
xgb_results %>%
collect_metrics() %>%
filter(.metric == "roc_auc") %>%
select(mean, mtry:sample_size) %>%
pivot_longer(mtry:sample_size,
values_to = "value",
names_to = "parameter"
) %>%
ggplot(aes(value, mean)) +
geom_point(alpha = 0.8, show.legend = FALSE, color="midnightblue") +
facet_wrap(~parameter, scales = "free_x") +
labs(x = NULL, y = "AUC")+
scale_color_brewer(palette = "Spectral")+
theme_minimal()
best_auc_model <- select_best(xgb_results,"roc_auc")
final_xgb <- finalize_workflow(
steph_workflow,
best_auc_model
)
final_xgb %>%
fit(data = steph_train) %>%
extract_fit_parsnip() %>%
vip(geom = "point") +
theme_minimal()
final_res <- last_fit(final_xgb, steph_split)
final_res %>%
collect_predictions() %>%
roc_curve(scoring_play, `.pred_FALSE`) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_line(linewidth = 1.5, color = "midnightblue") +
geom_abline(
lty = 2, alpha = 0.5,
color = "gray50",
linewidth = 1.2
)+theme_minimal()
nba_pbp %>%
filter(season <= 2023 &
athlete_id_1 == 3975 &
shooting_play == TRUE &
!grepl("Free Throw",type_text)) %>%
select(game_id,coordinate_x_raw,coordinate_y_raw,scoring_play,
clock_minutes, athlete_id_2,clock_minutes,clock_seconds,qtr) %>%
left_join(player_ids,by=c("athlete_id_2"="athlete_id")) %>%
inner_join(game_ids, by=join_by(game_id)) %>%
select(-athlete_id_2) %>%
rename(oponent_athlete=athlete_display_name) %>%
mutate(oponent_athlete = if_else(is.na(oponent_athlete),"no direct oponent",oponent_athlete),
scoring_play = fct_rev(as_factor(scoring_play))) -> base_steph_pbp
set.seed(123)
steph_split <- initial_split(base_steph_pbp, prop = 0.8, strata = scoring_play)
steph_train <- training(steph_split)
steph_test <- testing(steph_split)
steph_folds <- vfold_cv(steph_train, v = 10, strata = scoring_play)
# Preprocessing:
# Add new step to address NAs
steph_recipe <- recipe(scoring_play ~ ., data = steph_train) %>%
update_role(game_id, new_role = "ID") %>%
step_dummy(all_nominal(), -all_outcomes())
xgb_spec <- boost_tree(
trees = 1250,
tree_depth = tune(),
min_n = tune(),
loss_reduction = tune(),
sample_size = tune(),
mtry = tune(),
learn_rate = tune()
) %>%
set_engine("xgboost") %>%
set_mode("classification")
steph_workflow <- workflow() %>%
add_recipe(steph_recipe) %>%
add_model(xgb_spec)
xgb_grid <- grid_latin_hypercube(
tree_depth(),
min_n(),
loss_reduction(),
sample_size = sample_prop(),
finalize(mtry(), steph_train),
learn_rate(),
size = 30
)
doParallel::registerDoParallel() # Activate parallel computing
set.seed(1234)
xgb_results <-  tune_grid(
steph_workflow,
resamples = steph_folds,
grid = xgb_grid,
control = control_grid(save_pred = TRUE)
)
xgb_results %>%
collect_metrics() %>%
filter(.metric == "roc_auc") %>%
select(mean, mtry:sample_size) %>%
pivot_longer(mtry:sample_size,
values_to = "value",
names_to = "parameter"
) %>%
ggplot(aes(value, mean)) +
geom_point(alpha = 0.8, show.legend = FALSE, color="midnightblue") +
facet_wrap(~parameter, scales = "free_x") +
labs(x = NULL, y = "AUC")+
scale_color_brewer(palette = "Spectral")+
theme_minimal()
# Select best model and finalise workflow:
best_auc_model <- select_best(xgb_results,"roc_auc")
final_xgb <- finalize_workflow(
steph_workflow,
best_auc_model
)
final_xgb %>%
fit(data = steph_train) %>%
extract_fit_parsnip() %>%
vip(geom = "point") +
theme_minimal()
final_res <- last_fit(final_xgb, steph_split)
final_res %>%
collect_predictions() %>%
roc_curve(scoring_play, `.pred_TRUE`) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_line(linewidth = 1.5, color = "midnightblue") +
geom_abline(
lty = 2, alpha = 0.5,
color = "gray50",
linewidth = 1.2
)+theme_minimal()
final_res %>% augment(steph_test)
augment(final_res,steph_test)
final_res %>% extract_fit_parsnip()
final_res %>% extract_fit_parsnip() %>% tidy()
final_res %>% extract_fit_parsnip() %>% augment(steph_test)
final_xgb
augment(final_xgb,steph_test)
final_xgb %>%
fit(data = steph_train) -> fit_steph
augment(fit_steph,steph_test)
augment(fit_steph,steph_test)
augment(fit_steph,steph_test)%>%
roc_curve(truth = scoring_play, .pred_TRUE) %>%
autoplot()
final_res
final_res %>%
collect_predictions()
final_res %>%
collect_predictions() %>% %>%
final_res %>%
collect_predictions() %>%
roc_curve(truth = scoring_play, .pred_TRUE)  %>%
autoplot()
